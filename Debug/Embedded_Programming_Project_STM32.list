
Embedded_Programming_Project_STM32.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00000b80  08000188  08000188  00001188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  08000d08  08000d08  00002004  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  08000d08  08000d08  00002004  2**0
                  CONTENTS
  4 .ARM          00000000  08000d08  08000d08  00002004  2**0
                  CONTENTS
  5 .preinit_array 00000000  08000d08  08000d08  00002004  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08000d08  08000d08  00001d08  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08000d0c  08000d0c  00001d0c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000004  20000000  08000d10  00002000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .ccmram       00000000  10000000  10000000  00002004  2**0
                  CONTENTS
 10 .bss          00000068  20000004  20000004  00002004  2**2
                  ALLOC
 11 ._user_heap_stack 00000604  2000006c  2000006c  00002004  2**0
                  ALLOC
 12 .ARM.attributes 00000030  00000000  00000000  00002004  2**0
                  CONTENTS, READONLY
 13 .debug_info   00005f9f  00000000  00000000  00002034  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00000e80  00000000  00000000  00007fd3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000550  00000000  00000000  00008e58  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 0000041a  00000000  00000000  000093a8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0001f08d  00000000  00000000  000097c2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0000657c  00000000  00000000  0002884f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    000bf004  00000000  00000000  0002edcb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  000eddcf  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0000151c  00000000  00000000  000ede14  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000074  00000000  00000000  000ef330  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	b510      	push	{r4, lr}
 800018a:	4c05      	ldr	r4, [pc, #20]	@ (80001a0 <__do_global_dtors_aux+0x18>)
 800018c:	7823      	ldrb	r3, [r4, #0]
 800018e:	b933      	cbnz	r3, 800019e <__do_global_dtors_aux+0x16>
 8000190:	4b04      	ldr	r3, [pc, #16]	@ (80001a4 <__do_global_dtors_aux+0x1c>)
 8000192:	b113      	cbz	r3, 800019a <__do_global_dtors_aux+0x12>
 8000194:	4804      	ldr	r0, [pc, #16]	@ (80001a8 <__do_global_dtors_aux+0x20>)
 8000196:	f3af 8000 	nop.w
 800019a:	2301      	movs	r3, #1
 800019c:	7023      	strb	r3, [r4, #0]
 800019e:	bd10      	pop	{r4, pc}
 80001a0:	20000004 	.word	0x20000004
 80001a4:	00000000 	.word	0x00000000
 80001a8:	08000cf0 	.word	0x08000cf0

080001ac <frame_dummy>:
 80001ac:	b508      	push	{r3, lr}
 80001ae:	4b03      	ldr	r3, [pc, #12]	@ (80001bc <frame_dummy+0x10>)
 80001b0:	b11b      	cbz	r3, 80001ba <frame_dummy+0xe>
 80001b2:	4903      	ldr	r1, [pc, #12]	@ (80001c0 <frame_dummy+0x14>)
 80001b4:	4803      	ldr	r0, [pc, #12]	@ (80001c4 <frame_dummy+0x18>)
 80001b6:	f3af 8000 	nop.w
 80001ba:	bd08      	pop	{r3, pc}
 80001bc:	00000000 	.word	0x00000000
 80001c0:	20000008 	.word	0x20000008
 80001c4:	08000cf0 	.word	0x08000cf0

080001c8 <main>:

#include"main.h"


UART_HandleTypeDef huart2;
int main(void) {
 80001c8:	b480      	push	{r7}
 80001ca:	af00      	add	r7, sp, #0



	return 0;
 80001cc:	2300      	movs	r3, #0
}
 80001ce:	4618      	mov	r0, r3
 80001d0:	46bd      	mov	sp, r7
 80001d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80001d6:	4770      	bx	lr

080001d8 <SysTick_Handler>:

#include "main.h"

extern UART_HandleTypeDef	huart2;

void SysTick_Handler (void) {
 80001d8:	b580      	push	{r7, lr}
 80001da:	af00      	add	r7, sp, #0
	HAL_IncTick();
 80001dc:	f000 f84a 	bl	8000274 <HAL_IncTick>
	HAL_SYSTICK_IRQHandler();
 80001e0:	f000 f868 	bl	80002b4 <HAL_SYSTICK_IRQHandler>
}
 80001e4:	bf00      	nop
 80001e6:	bd80      	pop	{r7, pc}

080001e8 <USART2_IRQHandler>:

void USART2_IRQHandler(void) {
 80001e8:	b580      	push	{r7, lr}
 80001ea:	af00      	add	r7, sp, #0
	HAL_UART_IRQHandler(&huart2);
 80001ec:	4802      	ldr	r0, [pc, #8]	@ (80001f8 <USART2_IRQHandler+0x10>)
 80001ee:	f000 f901 	bl	80003f4 <HAL_UART_IRQHandler>
}
 80001f2:	bf00      	nop
 80001f4:	bd80      	pop	{r7, pc}
 80001f6:	bf00      	nop
 80001f8:	20000020 	.word	0x20000020

080001fc <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80001fc:	b480      	push	{r7}
 80001fe:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000200:	4b06      	ldr	r3, [pc, #24]	@ (800021c <SystemInit+0x20>)
 8000202:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8000206:	4a05      	ldr	r2, [pc, #20]	@ (800021c <SystemInit+0x20>)
 8000208:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 800020c:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8000210:	bf00      	nop
 8000212:	46bd      	mov	sp, r7
 8000214:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000218:	4770      	bx	lr
 800021a:	bf00      	nop
 800021c:	e000ed00 	.word	0xe000ed00

08000220 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8000220:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8000258 <LoopFillZerobss+0xe>
  
/* Call the clock system initialization function.*/
  bl  SystemInit  
 8000224:	f7ff ffea 	bl	80001fc <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8000228:	480c      	ldr	r0, [pc, #48]	@ (800025c <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 800022a:	490d      	ldr	r1, [pc, #52]	@ (8000260 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 800022c:	4a0d      	ldr	r2, [pc, #52]	@ (8000264 <LoopFillZerobss+0x1a>)
  movs r3, #0
 800022e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8000230:	e002      	b.n	8000238 <LoopCopyDataInit>

08000232 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000232:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000234:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000236:	3304      	adds	r3, #4

08000238 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000238:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800023a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800023c:	d3f9      	bcc.n	8000232 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800023e:	4a0a      	ldr	r2, [pc, #40]	@ (8000268 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8000240:	4c0a      	ldr	r4, [pc, #40]	@ (800026c <LoopFillZerobss+0x22>)
  movs r3, #0
 8000242:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000244:	e001      	b.n	800024a <LoopFillZerobss>

08000246 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000246:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000248:	3204      	adds	r2, #4

0800024a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800024a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800024c:	d3fb      	bcc.n	8000246 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 800024e:	f000 fd2b 	bl	8000ca8 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8000252:	f7ff ffb9 	bl	80001c8 <main>
  bx  lr    
 8000256:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 8000258:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 800025c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000260:	20000004 	.word	0x20000004
  ldr r2, =_sidata
 8000264:	08000d10 	.word	0x08000d10
  ldr r2, =_sbss
 8000268:	20000004 	.word	0x20000004
  ldr r4, =_ebss
 800026c:	2000006c 	.word	0x2000006c

08000270 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000270:	e7fe      	b.n	8000270 <ADC_IRQHandler>
	...

08000274 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8000274:	b480      	push	{r7}
 8000276:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8000278:	4b06      	ldr	r3, [pc, #24]	@ (8000294 <HAL_IncTick+0x20>)
 800027a:	781b      	ldrb	r3, [r3, #0]
 800027c:	461a      	mov	r2, r3
 800027e:	4b06      	ldr	r3, [pc, #24]	@ (8000298 <HAL_IncTick+0x24>)
 8000280:	681b      	ldr	r3, [r3, #0]
 8000282:	4413      	add	r3, r2
 8000284:	4a04      	ldr	r2, [pc, #16]	@ (8000298 <HAL_IncTick+0x24>)
 8000286:	6013      	str	r3, [r2, #0]
}
 8000288:	bf00      	nop
 800028a:	46bd      	mov	sp, r7
 800028c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000290:	4770      	bx	lr
 8000292:	bf00      	nop
 8000294:	20000000 	.word	0x20000000
 8000298:	20000068 	.word	0x20000068

0800029c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800029c:	b480      	push	{r7}
 800029e:	af00      	add	r7, sp, #0
  return uwTick;
 80002a0:	4b03      	ldr	r3, [pc, #12]	@ (80002b0 <HAL_GetTick+0x14>)
 80002a2:	681b      	ldr	r3, [r3, #0]
}
 80002a4:	4618      	mov	r0, r3
 80002a6:	46bd      	mov	sp, r7
 80002a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80002ac:	4770      	bx	lr
 80002ae:	bf00      	nop
 80002b0:	20000068 	.word	0x20000068

080002b4 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 80002b4:	b580      	push	{r7, lr}
 80002b6:	af00      	add	r7, sp, #0
  HAL_SYSTICK_Callback();
 80002b8:	f000 f802 	bl	80002c0 <HAL_SYSTICK_Callback>
}
 80002bc:	bf00      	nop
 80002be:	bd80      	pop	{r7, pc}

080002c0 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 80002c0:	b480      	push	{r7}
 80002c2:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
 80002c4:	bf00      	nop
 80002c6:	46bd      	mov	sp, r7
 80002c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80002cc:	4770      	bx	lr

080002ce <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 80002ce:	b580      	push	{r7, lr}
 80002d0:	b084      	sub	sp, #16
 80002d2:	af00      	add	r7, sp, #0
 80002d4:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 80002d6:	687b      	ldr	r3, [r7, #4]
 80002d8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80002da:	60fb      	str	r3, [r7, #12]
  
  uint32_t tickstart = HAL_GetTick();
 80002dc:	f7ff ffde 	bl	800029c <HAL_GetTick>
 80002e0:	60b8      	str	r0, [r7, #8]
  
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80002e2:	687b      	ldr	r3, [r7, #4]
 80002e4:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 80002e8:	b2db      	uxtb	r3, r3
 80002ea:	2b02      	cmp	r3, #2
 80002ec:	d008      	beq.n	8000300 <HAL_DMA_Abort+0x32>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80002ee:	687b      	ldr	r3, [r7, #4]
 80002f0:	2280      	movs	r2, #128	@ 0x80
 80002f2:	655a      	str	r2, [r3, #84]	@ 0x54
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80002f4:	687b      	ldr	r3, [r7, #4]
 80002f6:	2200      	movs	r2, #0
 80002f8:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    
    return HAL_ERROR;
 80002fc:	2301      	movs	r3, #1
 80002fe:	e052      	b.n	80003a6 <HAL_DMA_Abort+0xd8>
  }
  else
  {
    /* Disable all the transfer interrupts */
    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8000300:	687b      	ldr	r3, [r7, #4]
 8000302:	681b      	ldr	r3, [r3, #0]
 8000304:	681a      	ldr	r2, [r3, #0]
 8000306:	687b      	ldr	r3, [r7, #4]
 8000308:	681b      	ldr	r3, [r3, #0]
 800030a:	f022 0216 	bic.w	r2, r2, #22
 800030e:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR &= ~(DMA_IT_FE);
 8000310:	687b      	ldr	r3, [r7, #4]
 8000312:	681b      	ldr	r3, [r3, #0]
 8000314:	695a      	ldr	r2, [r3, #20]
 8000316:	687b      	ldr	r3, [r7, #4]
 8000318:	681b      	ldr	r3, [r3, #0]
 800031a:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 800031e:	615a      	str	r2, [r3, #20]
    
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8000320:	687b      	ldr	r3, [r7, #4]
 8000322:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8000324:	2b00      	cmp	r3, #0
 8000326:	d103      	bne.n	8000330 <HAL_DMA_Abort+0x62>
 8000328:	687b      	ldr	r3, [r7, #4]
 800032a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800032c:	2b00      	cmp	r3, #0
 800032e:	d007      	beq.n	8000340 <HAL_DMA_Abort+0x72>
    {
      hdma->Instance->CR  &= ~(DMA_IT_HT);
 8000330:	687b      	ldr	r3, [r7, #4]
 8000332:	681b      	ldr	r3, [r3, #0]
 8000334:	681a      	ldr	r2, [r3, #0]
 8000336:	687b      	ldr	r3, [r7, #4]
 8000338:	681b      	ldr	r3, [r3, #0]
 800033a:	f022 0208 	bic.w	r2, r2, #8
 800033e:	601a      	str	r2, [r3, #0]
    }
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8000340:	687b      	ldr	r3, [r7, #4]
 8000342:	681b      	ldr	r3, [r3, #0]
 8000344:	681a      	ldr	r2, [r3, #0]
 8000346:	687b      	ldr	r3, [r7, #4]
 8000348:	681b      	ldr	r3, [r3, #0]
 800034a:	f022 0201 	bic.w	r2, r2, #1
 800034e:	601a      	str	r2, [r3, #0]
    
    /* Check if the DMA Stream is effectively disabled */
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8000350:	e013      	b.n	800037a <HAL_DMA_Abort+0xac>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8000352:	f7ff ffa3 	bl	800029c <HAL_GetTick>
 8000356:	4602      	mov	r2, r0
 8000358:	68bb      	ldr	r3, [r7, #8]
 800035a:	1ad3      	subs	r3, r2, r3
 800035c:	2b05      	cmp	r3, #5
 800035e:	d90c      	bls.n	800037a <HAL_DMA_Abort+0xac>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8000360:	687b      	ldr	r3, [r7, #4]
 8000362:	2220      	movs	r2, #32
 8000364:	655a      	str	r2, [r3, #84]	@ 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 8000366:	687b      	ldr	r3, [r7, #4]
 8000368:	2203      	movs	r2, #3
 800036a:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
        
        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 800036e:	687b      	ldr	r3, [r7, #4]
 8000370:	2200      	movs	r2, #0
 8000372:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        
        return HAL_TIMEOUT;
 8000376:	2303      	movs	r3, #3
 8000378:	e015      	b.n	80003a6 <HAL_DMA_Abort+0xd8>
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 800037a:	687b      	ldr	r3, [r7, #4]
 800037c:	681b      	ldr	r3, [r3, #0]
 800037e:	681b      	ldr	r3, [r3, #0]
 8000380:	f003 0301 	and.w	r3, r3, #1
 8000384:	2b00      	cmp	r3, #0
 8000386:	d1e4      	bne.n	8000352 <HAL_DMA_Abort+0x84>
      }
    }
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8000388:	687b      	ldr	r3, [r7, #4]
 800038a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800038c:	223f      	movs	r2, #63	@ 0x3f
 800038e:	409a      	lsls	r2, r3
 8000390:	68fb      	ldr	r3, [r7, #12]
 8000392:	609a      	str	r2, [r3, #8]
    
    /* Change the DMA state*/
    hdma->State = HAL_DMA_STATE_READY;
 8000394:	687b      	ldr	r3, [r7, #4]
 8000396:	2201      	movs	r2, #1
 8000398:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800039c:	687b      	ldr	r3, [r7, #4]
 800039e:	2200      	movs	r2, #0
 80003a0:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  }
  return HAL_OK;
 80003a4:	2300      	movs	r3, #0
}
 80003a6:	4618      	mov	r0, r3
 80003a8:	3710      	adds	r7, #16
 80003aa:	46bd      	mov	sp, r7
 80003ac:	bd80      	pop	{r7, pc}

080003ae <HAL_DMA_Abort_IT>:
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 80003ae:	b480      	push	{r7}
 80003b0:	b083      	sub	sp, #12
 80003b2:	af00      	add	r7, sp, #0
 80003b4:	6078      	str	r0, [r7, #4]
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80003b6:	687b      	ldr	r3, [r7, #4]
 80003b8:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 80003bc:	b2db      	uxtb	r3, r3
 80003be:	2b02      	cmp	r3, #2
 80003c0:	d004      	beq.n	80003cc <HAL_DMA_Abort_IT+0x1e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80003c2:	687b      	ldr	r3, [r7, #4]
 80003c4:	2280      	movs	r2, #128	@ 0x80
 80003c6:	655a      	str	r2, [r3, #84]	@ 0x54
    return HAL_ERROR;
 80003c8:	2301      	movs	r3, #1
 80003ca:	e00c      	b.n	80003e6 <HAL_DMA_Abort_IT+0x38>
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 80003cc:	687b      	ldr	r3, [r7, #4]
 80003ce:	2205      	movs	r2, #5
 80003d0:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 80003d4:	687b      	ldr	r3, [r7, #4]
 80003d6:	681b      	ldr	r3, [r3, #0]
 80003d8:	681a      	ldr	r2, [r3, #0]
 80003da:	687b      	ldr	r3, [r7, #4]
 80003dc:	681b      	ldr	r3, [r3, #0]
 80003de:	f022 0201 	bic.w	r2, r2, #1
 80003e2:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
 80003e4:	2300      	movs	r3, #0
}
 80003e6:	4618      	mov	r0, r3
 80003e8:	370c      	adds	r7, #12
 80003ea:	46bd      	mov	sp, r7
 80003ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80003f0:	4770      	bx	lr
	...

080003f4 <HAL_UART_IRQHandler>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 80003f4:	b580      	push	{r7, lr}
 80003f6:	b0ba      	sub	sp, #232	@ 0xe8
 80003f8:	af00      	add	r7, sp, #0
 80003fa:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 80003fc:	687b      	ldr	r3, [r7, #4]
 80003fe:	681b      	ldr	r3, [r3, #0]
 8000400:	681b      	ldr	r3, [r3, #0]
 8000402:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8000406:	687b      	ldr	r3, [r7, #4]
 8000408:	681b      	ldr	r3, [r3, #0]
 800040a:	68db      	ldr	r3, [r3, #12]
 800040c:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8000410:	687b      	ldr	r3, [r7, #4]
 8000412:	681b      	ldr	r3, [r3, #0]
 8000414:	695b      	ldr	r3, [r3, #20]
 8000416:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
  uint32_t errorflags = 0x00U;
 800041a:	2300      	movs	r3, #0
 800041c:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
  uint32_t dmarequest = 0x00U;
 8000420:	2300      	movs	r3, #0
 8000422:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
 8000426:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 800042a:	f003 030f 	and.w	r3, r3, #15
 800042e:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
  if (errorflags == RESET)
 8000432:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8000436:	2b00      	cmp	r3, #0
 8000438:	d10f      	bne.n	800045a <HAL_UART_IRQHandler+0x66>
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 800043a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 800043e:	f003 0320 	and.w	r3, r3, #32
 8000442:	2b00      	cmp	r3, #0
 8000444:	d009      	beq.n	800045a <HAL_UART_IRQHandler+0x66>
 8000446:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 800044a:	f003 0320 	and.w	r3, r3, #32
 800044e:	2b00      	cmp	r3, #0
 8000450:	d003      	beq.n	800045a <HAL_UART_IRQHandler+0x66>
    {
      UART_Receive_IT(huart);
 8000452:	6878      	ldr	r0, [r7, #4]
 8000454:	f000 fb69 	bl	8000b2a <UART_Receive_IT>
      return;
 8000458:	e25b      	b.n	8000912 <HAL_UART_IRQHandler+0x51e>
    }
  }

  /* If some errors occur */
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET)
 800045a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 800045e:	2b00      	cmp	r3, #0
 8000460:	f000 80de 	beq.w	8000620 <HAL_UART_IRQHandler+0x22c>
 8000464:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8000468:	f003 0301 	and.w	r3, r3, #1
 800046c:	2b00      	cmp	r3, #0
 800046e:	d106      	bne.n	800047e <HAL_UART_IRQHandler+0x8a>
                                || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8000470:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8000474:	f403 7390 	and.w	r3, r3, #288	@ 0x120
 8000478:	2b00      	cmp	r3, #0
 800047a:	f000 80d1 	beq.w	8000620 <HAL_UART_IRQHandler+0x22c>
  {
    /* UART parity error interrupt occurred ----------------------------------*/
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 800047e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8000482:	f003 0301 	and.w	r3, r3, #1
 8000486:	2b00      	cmp	r3, #0
 8000488:	d00b      	beq.n	80004a2 <HAL_UART_IRQHandler+0xae>
 800048a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 800048e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8000492:	2b00      	cmp	r3, #0
 8000494:	d005      	beq.n	80004a2 <HAL_UART_IRQHandler+0xae>
    {
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8000496:	687b      	ldr	r3, [r7, #4]
 8000498:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800049a:	f043 0201 	orr.w	r2, r3, #1
 800049e:	687b      	ldr	r3, [r7, #4]
 80004a0:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    /* UART noise error interrupt occurred -----------------------------------*/
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80004a2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80004a6:	f003 0304 	and.w	r3, r3, #4
 80004aa:	2b00      	cmp	r3, #0
 80004ac:	d00b      	beq.n	80004c6 <HAL_UART_IRQHandler+0xd2>
 80004ae:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80004b2:	f003 0301 	and.w	r3, r3, #1
 80004b6:	2b00      	cmp	r3, #0
 80004b8:	d005      	beq.n	80004c6 <HAL_UART_IRQHandler+0xd2>
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80004ba:	687b      	ldr	r3, [r7, #4]
 80004bc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80004be:	f043 0202 	orr.w	r2, r3, #2
 80004c2:	687b      	ldr	r3, [r7, #4]
 80004c4:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    /* UART frame error interrupt occurred -----------------------------------*/
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80004c6:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80004ca:	f003 0302 	and.w	r3, r3, #2
 80004ce:	2b00      	cmp	r3, #0
 80004d0:	d00b      	beq.n	80004ea <HAL_UART_IRQHandler+0xf6>
 80004d2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80004d6:	f003 0301 	and.w	r3, r3, #1
 80004da:	2b00      	cmp	r3, #0
 80004dc:	d005      	beq.n	80004ea <HAL_UART_IRQHandler+0xf6>
    {
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80004de:	687b      	ldr	r3, [r7, #4]
 80004e0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80004e2:	f043 0204 	orr.w	r2, r3, #4
 80004e6:	687b      	ldr	r3, [r7, #4]
 80004e8:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    /* UART Over-Run interrupt occurred --------------------------------------*/
    if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET)
 80004ea:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80004ee:	f003 0308 	and.w	r3, r3, #8
 80004f2:	2b00      	cmp	r3, #0
 80004f4:	d011      	beq.n	800051a <HAL_UART_IRQHandler+0x126>
 80004f6:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80004fa:	f003 0320 	and.w	r3, r3, #32
 80004fe:	2b00      	cmp	r3, #0
 8000500:	d105      	bne.n	800050e <HAL_UART_IRQHandler+0x11a>
                                                 || ((cr3its & USART_CR3_EIE) != RESET)))
 8000502:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8000506:	f003 0301 	and.w	r3, r3, #1
 800050a:	2b00      	cmp	r3, #0
 800050c:	d005      	beq.n	800051a <HAL_UART_IRQHandler+0x126>
    {
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 800050e:	687b      	ldr	r3, [r7, #4]
 8000510:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8000512:	f043 0208 	orr.w	r2, r3, #8
 8000516:	687b      	ldr	r3, [r7, #4]
 8000518:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    /* Call UART Error Call back function if need be --------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 800051a:	687b      	ldr	r3, [r7, #4]
 800051c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800051e:	2b00      	cmp	r3, #0
 8000520:	f000 81f2 	beq.w	8000908 <HAL_UART_IRQHandler+0x514>
    {
      /* UART in mode Receiver -----------------------------------------------*/
      if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8000524:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8000528:	f003 0320 	and.w	r3, r3, #32
 800052c:	2b00      	cmp	r3, #0
 800052e:	d008      	beq.n	8000542 <HAL_UART_IRQHandler+0x14e>
 8000530:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8000534:	f003 0320 	and.w	r3, r3, #32
 8000538:	2b00      	cmp	r3, #0
 800053a:	d002      	beq.n	8000542 <HAL_UART_IRQHandler+0x14e>
      {
        UART_Receive_IT(huart);
 800053c:	6878      	ldr	r0, [r7, #4]
 800053e:	f000 faf4 	bl	8000b2a <UART_Receive_IT>
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8000542:	687b      	ldr	r3, [r7, #4]
 8000544:	681b      	ldr	r3, [r3, #0]
 8000546:	695b      	ldr	r3, [r3, #20]
 8000548:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800054c:	2b40      	cmp	r3, #64	@ 0x40
 800054e:	bf0c      	ite	eq
 8000550:	2301      	moveq	r3, #1
 8000552:	2300      	movne	r3, #0
 8000554:	b2db      	uxtb	r3, r3
 8000556:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 800055a:	687b      	ldr	r3, [r7, #4]
 800055c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800055e:	f003 0308 	and.w	r3, r3, #8
 8000562:	2b00      	cmp	r3, #0
 8000564:	d103      	bne.n	800056e <HAL_UART_IRQHandler+0x17a>
 8000566:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800056a:	2b00      	cmp	r3, #0
 800056c:	d04f      	beq.n	800060e <HAL_UART_IRQHandler+0x21a>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 800056e:	6878      	ldr	r0, [r7, #4]
 8000570:	f000 f9fc 	bl	800096c <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8000574:	687b      	ldr	r3, [r7, #4]
 8000576:	681b      	ldr	r3, [r3, #0]
 8000578:	695b      	ldr	r3, [r3, #20]
 800057a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800057e:	2b40      	cmp	r3, #64	@ 0x40
 8000580:	d141      	bne.n	8000606 <HAL_UART_IRQHandler+0x212>
        {
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8000582:	687b      	ldr	r3, [r7, #4]
 8000584:	681b      	ldr	r3, [r3, #0]
 8000586:	3314      	adds	r3, #20
 8000588:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800058c:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8000590:	e853 3f00 	ldrex	r3, [r3]
 8000594:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
   return(result);
 8000598:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 800059c:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80005a0:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 80005a4:	687b      	ldr	r3, [r7, #4]
 80005a6:	681b      	ldr	r3, [r3, #0]
 80005a8:	3314      	adds	r3, #20
 80005aa:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 80005ae:	f8c7 20a8 	str.w	r2, [r7, #168]	@ 0xa8
 80005b2:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80005b6:	f8d7 10a4 	ldr.w	r1, [r7, #164]	@ 0xa4
 80005ba:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 80005be:	e841 2300 	strex	r3, r2, [r1]
 80005c2:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
   return(result);
 80005c6:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 80005ca:	2b00      	cmp	r3, #0
 80005cc:	d1d9      	bne.n	8000582 <HAL_UART_IRQHandler+0x18e>

          /* Abort the UART DMA Rx stream */
          if (huart->hdmarx != NULL)
 80005ce:	687b      	ldr	r3, [r7, #4]
 80005d0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80005d2:	2b00      	cmp	r3, #0
 80005d4:	d013      	beq.n	80005fe <HAL_UART_IRQHandler+0x20a>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 80005d6:	687b      	ldr	r3, [r7, #4]
 80005d8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80005da:	4a7e      	ldr	r2, [pc, #504]	@ (80007d4 <HAL_UART_IRQHandler+0x3e0>)
 80005dc:	651a      	str	r2, [r3, #80]	@ 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 80005de:	687b      	ldr	r3, [r7, #4]
 80005e0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80005e2:	4618      	mov	r0, r3
 80005e4:	f7ff fee3 	bl	80003ae <HAL_DMA_Abort_IT>
 80005e8:	4603      	mov	r3, r0
 80005ea:	2b00      	cmp	r3, #0
 80005ec:	d016      	beq.n	800061c <HAL_UART_IRQHandler+0x228>
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 80005ee:	687b      	ldr	r3, [r7, #4]
 80005f0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80005f2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80005f4:	687a      	ldr	r2, [r7, #4]
 80005f6:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 80005f8:	4610      	mov	r0, r2
 80005fa:	4798      	blx	r3
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80005fc:	e00e      	b.n	800061c <HAL_UART_IRQHandler+0x228>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 80005fe:	6878      	ldr	r0, [r7, #4]
 8000600:	f000 f99e 	bl	8000940 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8000604:	e00a      	b.n	800061c <HAL_UART_IRQHandler+0x228>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 8000606:	6878      	ldr	r0, [r7, #4]
 8000608:	f000 f99a 	bl	8000940 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800060c:	e006      	b.n	800061c <HAL_UART_IRQHandler+0x228>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 800060e:	6878      	ldr	r0, [r7, #4]
 8000610:	f000 f996 	bl	8000940 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8000614:	687b      	ldr	r3, [r7, #4]
 8000616:	2200      	movs	r2, #0
 8000618:	645a      	str	r2, [r3, #68]	@ 0x44
      }
    }
    return;
 800061a:	e175      	b.n	8000908 <HAL_UART_IRQHandler+0x514>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800061c:	bf00      	nop
    return;
 800061e:	e173      	b.n	8000908 <HAL_UART_IRQHandler+0x514>
  } /* End if some error occurs */

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : */
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8000620:	687b      	ldr	r3, [r7, #4]
 8000622:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8000624:	2b01      	cmp	r3, #1
 8000626:	f040 814f 	bne.w	80008c8 <HAL_UART_IRQHandler+0x4d4>
      && ((isrflags & USART_SR_IDLE) != 0U)
 800062a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 800062e:	f003 0310 	and.w	r3, r3, #16
 8000632:	2b00      	cmp	r3, #0
 8000634:	f000 8148 	beq.w	80008c8 <HAL_UART_IRQHandler+0x4d4>
      && ((cr1its & USART_SR_IDLE) != 0U))
 8000638:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 800063c:	f003 0310 	and.w	r3, r3, #16
 8000640:	2b00      	cmp	r3, #0
 8000642:	f000 8141 	beq.w	80008c8 <HAL_UART_IRQHandler+0x4d4>
  {
    __HAL_UART_CLEAR_IDLEFLAG(huart);
 8000646:	2300      	movs	r3, #0
 8000648:	60bb      	str	r3, [r7, #8]
 800064a:	687b      	ldr	r3, [r7, #4]
 800064c:	681b      	ldr	r3, [r3, #0]
 800064e:	681b      	ldr	r3, [r3, #0]
 8000650:	60bb      	str	r3, [r7, #8]
 8000652:	687b      	ldr	r3, [r7, #4]
 8000654:	681b      	ldr	r3, [r3, #0]
 8000656:	685b      	ldr	r3, [r3, #4]
 8000658:	60bb      	str	r3, [r7, #8]
 800065a:	68bb      	ldr	r3, [r7, #8]

    /* Check if DMA mode is enabled in UART */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800065c:	687b      	ldr	r3, [r7, #4]
 800065e:	681b      	ldr	r3, [r3, #0]
 8000660:	695b      	ldr	r3, [r3, #20]
 8000662:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8000666:	2b40      	cmp	r3, #64	@ 0x40
 8000668:	f040 80b6 	bne.w	80007d8 <HAL_UART_IRQHandler+0x3e4>
    {
      /* DMA mode enabled */
      /* Check received length : If all expected data are received, do nothing,
         (DMA cplt callback will be called).
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 800066c:	687b      	ldr	r3, [r7, #4]
 800066e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8000670:	681b      	ldr	r3, [r3, #0]
 8000672:	685b      	ldr	r3, [r3, #4]
 8000674:	f8a7 30be 	strh.w	r3, [r7, #190]	@ 0xbe
      if ((nb_remaining_rx_data > 0U)
 8000678:	f8b7 30be 	ldrh.w	r3, [r7, #190]	@ 0xbe
 800067c:	2b00      	cmp	r3, #0
 800067e:	f000 8145 	beq.w	800090c <HAL_UART_IRQHandler+0x518>
          && (nb_remaining_rx_data < huart->RxXferSize))
 8000682:	687b      	ldr	r3, [r7, #4]
 8000684:	8d9b      	ldrh	r3, [r3, #44]	@ 0x2c
 8000686:	f8b7 20be 	ldrh.w	r2, [r7, #190]	@ 0xbe
 800068a:	429a      	cmp	r2, r3
 800068c:	f080 813e 	bcs.w	800090c <HAL_UART_IRQHandler+0x518>
      {
        /* Reception is not complete */
        huart->RxXferCount = nb_remaining_rx_data;
 8000690:	687b      	ldr	r3, [r7, #4]
 8000692:	f8b7 20be 	ldrh.w	r2, [r7, #190]	@ 0xbe
 8000696:	85da      	strh	r2, [r3, #46]	@ 0x2e

        /* In Normal mode, end DMA xfer and HAL UART Rx process*/
        if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
 8000698:	687b      	ldr	r3, [r7, #4]
 800069a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800069c:	69db      	ldr	r3, [r3, #28]
 800069e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80006a2:	f000 8088 	beq.w	80007b6 <HAL_UART_IRQHandler+0x3c2>
        {
          /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80006a6:	687b      	ldr	r3, [r7, #4]
 80006a8:	681b      	ldr	r3, [r3, #0]
 80006aa:	330c      	adds	r3, #12
 80006ac:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80006b0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80006b4:	e853 3f00 	ldrex	r3, [r3]
 80006b8:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
   return(result);
 80006bc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80006c0:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 80006c4:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 80006c8:	687b      	ldr	r3, [r7, #4]
 80006ca:	681b      	ldr	r3, [r3, #0]
 80006cc:	330c      	adds	r3, #12
 80006ce:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 80006d2:	f8c7 2094 	str.w	r2, [r7, #148]	@ 0x94
 80006d6:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80006da:	f8d7 1090 	ldr.w	r1, [r7, #144]	@ 0x90
 80006de:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 80006e2:	e841 2300 	strex	r3, r2, [r1]
 80006e6:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
   return(result);
 80006ea:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80006ee:	2b00      	cmp	r3, #0
 80006f0:	d1d9      	bne.n	80006a6 <HAL_UART_IRQHandler+0x2b2>
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80006f2:	687b      	ldr	r3, [r7, #4]
 80006f4:	681b      	ldr	r3, [r3, #0]
 80006f6:	3314      	adds	r3, #20
 80006f8:	677b      	str	r3, [r7, #116]	@ 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80006fa:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80006fc:	e853 3f00 	ldrex	r3, [r3]
 8000700:	673b      	str	r3, [r7, #112]	@ 0x70
   return(result);
 8000702:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8000704:	f023 0301 	bic.w	r3, r3, #1
 8000708:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 800070c:	687b      	ldr	r3, [r7, #4]
 800070e:	681b      	ldr	r3, [r3, #0]
 8000710:	3314      	adds	r3, #20
 8000712:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8000716:	f8c7 2080 	str.w	r2, [r7, #128]	@ 0x80
 800071a:	67fb      	str	r3, [r7, #124]	@ 0x7c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800071c:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
 800071e:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 8000722:	e841 2300 	strex	r3, r2, [r1]
 8000726:	67bb      	str	r3, [r7, #120]	@ 0x78
   return(result);
 8000728:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800072a:	2b00      	cmp	r3, #0
 800072c:	d1e1      	bne.n	80006f2 <HAL_UART_IRQHandler+0x2fe>

          /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
             in the UART CR3 register */
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800072e:	687b      	ldr	r3, [r7, #4]
 8000730:	681b      	ldr	r3, [r3, #0]
 8000732:	3314      	adds	r3, #20
 8000734:	663b      	str	r3, [r7, #96]	@ 0x60
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8000736:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8000738:	e853 3f00 	ldrex	r3, [r3]
 800073c:	65fb      	str	r3, [r7, #92]	@ 0x5c
   return(result);
 800073e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8000740:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8000744:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 8000748:	687b      	ldr	r3, [r7, #4]
 800074a:	681b      	ldr	r3, [r3, #0]
 800074c:	3314      	adds	r3, #20
 800074e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8000752:	66fa      	str	r2, [r7, #108]	@ 0x6c
 8000754:	66bb      	str	r3, [r7, #104]	@ 0x68
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8000756:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8000758:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 800075a:	e841 2300 	strex	r3, r2, [r1]
 800075e:	667b      	str	r3, [r7, #100]	@ 0x64
   return(result);
 8000760:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8000762:	2b00      	cmp	r3, #0
 8000764:	d1e3      	bne.n	800072e <HAL_UART_IRQHandler+0x33a>

          /* At end of Rx process, restore huart->RxState to Ready */
          huart->RxState = HAL_UART_STATE_READY;
 8000766:	687b      	ldr	r3, [r7, #4]
 8000768:	2220      	movs	r2, #32
 800076a:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800076e:	687b      	ldr	r3, [r7, #4]
 8000770:	2200      	movs	r2, #0
 8000772:	631a      	str	r2, [r3, #48]	@ 0x30

          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8000774:	687b      	ldr	r3, [r7, #4]
 8000776:	681b      	ldr	r3, [r3, #0]
 8000778:	330c      	adds	r3, #12
 800077a:	64fb      	str	r3, [r7, #76]	@ 0x4c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800077c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800077e:	e853 3f00 	ldrex	r3, [r3]
 8000782:	64bb      	str	r3, [r7, #72]	@ 0x48
   return(result);
 8000784:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8000786:	f023 0310 	bic.w	r3, r3, #16
 800078a:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
 800078e:	687b      	ldr	r3, [r7, #4]
 8000790:	681b      	ldr	r3, [r3, #0]
 8000792:	330c      	adds	r3, #12
 8000794:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8000798:	65ba      	str	r2, [r7, #88]	@ 0x58
 800079a:	657b      	str	r3, [r7, #84]	@ 0x54
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800079c:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 800079e:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80007a0:	e841 2300 	strex	r3, r2, [r1]
 80007a4:	653b      	str	r3, [r7, #80]	@ 0x50
   return(result);
 80007a6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80007a8:	2b00      	cmp	r3, #0
 80007aa:	d1e3      	bne.n	8000774 <HAL_UART_IRQHandler+0x380>

          /* Last bytes received, so no need as the abort is immediate */
          (void)HAL_DMA_Abort(huart->hdmarx);
 80007ac:	687b      	ldr	r3, [r7, #4]
 80007ae:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80007b0:	4618      	mov	r0, r3
 80007b2:	f7ff fd8c 	bl	80002ce <HAL_DMA_Abort>
        }

        /* Initialize type of RxEvent that correspond to RxEvent callback execution;
        In this case, Rx Event type is Idle Event */
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 80007b6:	687b      	ldr	r3, [r7, #4]
 80007b8:	2202      	movs	r2, #2
 80007ba:	635a      	str	r2, [r3, #52]	@ 0x34
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 80007bc:	687b      	ldr	r3, [r7, #4]
 80007be:	8d9a      	ldrh	r2, [r3, #44]	@ 0x2c
 80007c0:	687b      	ldr	r3, [r7, #4]
 80007c2:	8ddb      	ldrh	r3, [r3, #46]	@ 0x2e
 80007c4:	b29b      	uxth	r3, r3
 80007c6:	1ad3      	subs	r3, r2, r3
 80007c8:	b29b      	uxth	r3, r3
 80007ca:	4619      	mov	r1, r3
 80007cc:	6878      	ldr	r0, [r7, #4]
 80007ce:	f000 f8c1 	bl	8000954 <HAL_UARTEx_RxEventCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      }
      return;
 80007d2:	e09b      	b.n	800090c <HAL_UART_IRQHandler+0x518>
 80007d4:	08000a33 	.word	0x08000a33
    else
    {
      /* DMA mode not enabled */
      /* Check received length : If all expected data are received, do nothing.
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80007d8:	687b      	ldr	r3, [r7, #4]
 80007da:	8d9a      	ldrh	r2, [r3, #44]	@ 0x2c
 80007dc:	687b      	ldr	r3, [r7, #4]
 80007de:	8ddb      	ldrh	r3, [r3, #46]	@ 0x2e
 80007e0:	b29b      	uxth	r3, r3
 80007e2:	1ad3      	subs	r3, r2, r3
 80007e4:	f8a7 30ce 	strh.w	r3, [r7, #206]	@ 0xce
      if ((huart->RxXferCount > 0U)
 80007e8:	687b      	ldr	r3, [r7, #4]
 80007ea:	8ddb      	ldrh	r3, [r3, #46]	@ 0x2e
 80007ec:	b29b      	uxth	r3, r3
 80007ee:	2b00      	cmp	r3, #0
 80007f0:	f000 808e 	beq.w	8000910 <HAL_UART_IRQHandler+0x51c>
          && (nb_rx_data > 0U))
 80007f4:	f8b7 30ce 	ldrh.w	r3, [r7, #206]	@ 0xce
 80007f8:	2b00      	cmp	r3, #0
 80007fa:	f000 8089 	beq.w	8000910 <HAL_UART_IRQHandler+0x51c>
      {
        /* Disable the UART Parity Error Interrupt and RXNE interrupts */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80007fe:	687b      	ldr	r3, [r7, #4]
 8000800:	681b      	ldr	r3, [r3, #0]
 8000802:	330c      	adds	r3, #12
 8000804:	63bb      	str	r3, [r7, #56]	@ 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8000806:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8000808:	e853 3f00 	ldrex	r3, [r3]
 800080c:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
 800080e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8000810:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 8000814:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8000818:	687b      	ldr	r3, [r7, #4]
 800081a:	681b      	ldr	r3, [r3, #0]
 800081c:	330c      	adds	r3, #12
 800081e:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8000822:	647a      	str	r2, [r7, #68]	@ 0x44
 8000824:	643b      	str	r3, [r7, #64]	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8000826:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 8000828:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800082a:	e841 2300 	strex	r3, r2, [r1]
 800082e:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
 8000830:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8000832:	2b00      	cmp	r3, #0
 8000834:	d1e3      	bne.n	80007fe <HAL_UART_IRQHandler+0x40a>

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8000836:	687b      	ldr	r3, [r7, #4]
 8000838:	681b      	ldr	r3, [r3, #0]
 800083a:	3314      	adds	r3, #20
 800083c:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800083e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8000840:	e853 3f00 	ldrex	r3, [r3]
 8000844:	623b      	str	r3, [r7, #32]
   return(result);
 8000846:	6a3b      	ldr	r3, [r7, #32]
 8000848:	f023 0301 	bic.w	r3, r3, #1
 800084c:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8000850:	687b      	ldr	r3, [r7, #4]
 8000852:	681b      	ldr	r3, [r3, #0]
 8000854:	3314      	adds	r3, #20
 8000856:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 800085a:	633a      	str	r2, [r7, #48]	@ 0x30
 800085c:	62fb      	str	r3, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800085e:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8000860:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8000862:	e841 2300 	strex	r3, r2, [r1]
 8000866:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
 8000868:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800086a:	2b00      	cmp	r3, #0
 800086c:	d1e3      	bne.n	8000836 <HAL_UART_IRQHandler+0x442>

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 800086e:	687b      	ldr	r3, [r7, #4]
 8000870:	2220      	movs	r2, #32
 8000872:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8000876:	687b      	ldr	r3, [r7, #4]
 8000878:	2200      	movs	r2, #0
 800087a:	631a      	str	r2, [r3, #48]	@ 0x30

        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800087c:	687b      	ldr	r3, [r7, #4]
 800087e:	681b      	ldr	r3, [r3, #0]
 8000880:	330c      	adds	r3, #12
 8000882:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8000884:	693b      	ldr	r3, [r7, #16]
 8000886:	e853 3f00 	ldrex	r3, [r3]
 800088a:	60fb      	str	r3, [r7, #12]
   return(result);
 800088c:	68fb      	ldr	r3, [r7, #12]
 800088e:	f023 0310 	bic.w	r3, r3, #16
 8000892:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 8000896:	687b      	ldr	r3, [r7, #4]
 8000898:	681b      	ldr	r3, [r3, #0]
 800089a:	330c      	adds	r3, #12
 800089c:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 80008a0:	61fa      	str	r2, [r7, #28]
 80008a2:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80008a4:	69b9      	ldr	r1, [r7, #24]
 80008a6:	69fa      	ldr	r2, [r7, #28]
 80008a8:	e841 2300 	strex	r3, r2, [r1]
 80008ac:	617b      	str	r3, [r7, #20]
   return(result);
 80008ae:	697b      	ldr	r3, [r7, #20]
 80008b0:	2b00      	cmp	r3, #0
 80008b2:	d1e3      	bne.n	800087c <HAL_UART_IRQHandler+0x488>

        /* Initialize type of RxEvent that correspond to RxEvent callback execution;
           In this case, Rx Event type is Idle Event */
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 80008b4:	687b      	ldr	r3, [r7, #4]
 80008b6:	2202      	movs	r2, #2
 80008b8:	635a      	str	r2, [r3, #52]	@ 0x34
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxEventCallback(huart, nb_rx_data);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 80008ba:	f8b7 30ce 	ldrh.w	r3, [r7, #206]	@ 0xce
 80008be:	4619      	mov	r1, r3
 80008c0:	6878      	ldr	r0, [r7, #4]
 80008c2:	f000 f847 	bl	8000954 <HAL_UARTEx_RxEventCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      }
      return;
 80008c6:	e023      	b.n	8000910 <HAL_UART_IRQHandler+0x51c>
    }
  }

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 80008c8:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80008cc:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80008d0:	2b00      	cmp	r3, #0
 80008d2:	d009      	beq.n	80008e8 <HAL_UART_IRQHandler+0x4f4>
 80008d4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80008d8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80008dc:	2b00      	cmp	r3, #0
 80008de:	d003      	beq.n	80008e8 <HAL_UART_IRQHandler+0x4f4>
  {
    UART_Transmit_IT(huart);
 80008e0:	6878      	ldr	r0, [r7, #4]
 80008e2:	f000 f8ba 	bl	8000a5a <UART_Transmit_IT>
    return;
 80008e6:	e014      	b.n	8000912 <HAL_UART_IRQHandler+0x51e>
  }

  /* UART in mode Transmitter end --------------------------------------------*/
  if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 80008e8:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80008ec:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80008f0:	2b00      	cmp	r3, #0
 80008f2:	d00e      	beq.n	8000912 <HAL_UART_IRQHandler+0x51e>
 80008f4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80008f8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80008fc:	2b00      	cmp	r3, #0
 80008fe:	d008      	beq.n	8000912 <HAL_UART_IRQHandler+0x51e>
  {
    UART_EndTransmit_IT(huart);
 8000900:	6878      	ldr	r0, [r7, #4]
 8000902:	f000 f8fa 	bl	8000afa <UART_EndTransmit_IT>
    return;
 8000906:	e004      	b.n	8000912 <HAL_UART_IRQHandler+0x51e>
    return;
 8000908:	bf00      	nop
 800090a:	e002      	b.n	8000912 <HAL_UART_IRQHandler+0x51e>
      return;
 800090c:	bf00      	nop
 800090e:	e000      	b.n	8000912 <HAL_UART_IRQHandler+0x51e>
      return;
 8000910:	bf00      	nop
  }
}
 8000912:	37e8      	adds	r7, #232	@ 0xe8
 8000914:	46bd      	mov	sp, r7
 8000916:	bd80      	pop	{r7, pc}

08000918 <HAL_UART_TxCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 8000918:	b480      	push	{r7}
 800091a:	b083      	sub	sp, #12
 800091c:	af00      	add	r7, sp, #0
 800091e:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_TxCpltCallback could be implemented in the user file
   */
}
 8000920:	bf00      	nop
 8000922:	370c      	adds	r7, #12
 8000924:	46bd      	mov	sp, r7
 8000926:	f85d 7b04 	ldr.w	r7, [sp], #4
 800092a:	4770      	bx	lr

0800092c <HAL_UART_RxCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 800092c:	b480      	push	{r7}
 800092e:	b083      	sub	sp, #12
 8000930:	af00      	add	r7, sp, #0
 8000932:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxCpltCallback could be implemented in the user file
   */
}
 8000934:	bf00      	nop
 8000936:	370c      	adds	r7, #12
 8000938:	46bd      	mov	sp, r7
 800093a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800093e:	4770      	bx	lr

08000940 <HAL_UART_ErrorCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8000940:	b480      	push	{r7}
 8000942:	b083      	sub	sp, #12
 8000944:	af00      	add	r7, sp, #0
 8000946:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_ErrorCallback could be implemented in the user file
   */
}
 8000948:	bf00      	nop
 800094a:	370c      	adds	r7, #12
 800094c:	46bd      	mov	sp, r7
 800094e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000952:	4770      	bx	lr

08000954 <HAL_UARTEx_RxEventCallback>:
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */
__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
 8000954:	b480      	push	{r7}
 8000956:	b083      	sub	sp, #12
 8000958:	af00      	add	r7, sp, #0
 800095a:	6078      	str	r0, [r7, #4]
 800095c:	460b      	mov	r3, r1
 800095e:	807b      	strh	r3, [r7, #2]
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
 8000960:	bf00      	nop
 8000962:	370c      	adds	r7, #12
 8000964:	46bd      	mov	sp, r7
 8000966:	f85d 7b04 	ldr.w	r7, [sp], #4
 800096a:	4770      	bx	lr

0800096c <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 800096c:	b480      	push	{r7}
 800096e:	b095      	sub	sp, #84	@ 0x54
 8000970:	af00      	add	r7, sp, #0
 8000972:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8000974:	687b      	ldr	r3, [r7, #4]
 8000976:	681b      	ldr	r3, [r3, #0]
 8000978:	330c      	adds	r3, #12
 800097a:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800097c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800097e:	e853 3f00 	ldrex	r3, [r3]
 8000982:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
 8000984:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8000986:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 800098a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800098c:	687b      	ldr	r3, [r7, #4]
 800098e:	681b      	ldr	r3, [r3, #0]
 8000990:	330c      	adds	r3, #12
 8000992:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8000994:	643a      	str	r2, [r7, #64]	@ 0x40
 8000996:	63fb      	str	r3, [r7, #60]	@ 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8000998:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 800099a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800099c:	e841 2300 	strex	r3, r2, [r1]
 80009a0:	63bb      	str	r3, [r7, #56]	@ 0x38
   return(result);
 80009a2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80009a4:	2b00      	cmp	r3, #0
 80009a6:	d1e5      	bne.n	8000974 <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80009a8:	687b      	ldr	r3, [r7, #4]
 80009aa:	681b      	ldr	r3, [r3, #0]
 80009ac:	3314      	adds	r3, #20
 80009ae:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80009b0:	6a3b      	ldr	r3, [r7, #32]
 80009b2:	e853 3f00 	ldrex	r3, [r3]
 80009b6:	61fb      	str	r3, [r7, #28]
   return(result);
 80009b8:	69fb      	ldr	r3, [r7, #28]
 80009ba:	f023 0301 	bic.w	r3, r3, #1
 80009be:	64bb      	str	r3, [r7, #72]	@ 0x48
 80009c0:	687b      	ldr	r3, [r7, #4]
 80009c2:	681b      	ldr	r3, [r3, #0]
 80009c4:	3314      	adds	r3, #20
 80009c6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80009c8:	62fa      	str	r2, [r7, #44]	@ 0x2c
 80009ca:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80009cc:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 80009ce:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80009d0:	e841 2300 	strex	r3, r2, [r1]
 80009d4:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
 80009d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80009d8:	2b00      	cmp	r3, #0
 80009da:	d1e5      	bne.n	80009a8 <UART_EndRxTransfer+0x3c>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80009dc:	687b      	ldr	r3, [r7, #4]
 80009de:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80009e0:	2b01      	cmp	r3, #1
 80009e2:	d119      	bne.n	8000a18 <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80009e4:	687b      	ldr	r3, [r7, #4]
 80009e6:	681b      	ldr	r3, [r3, #0]
 80009e8:	330c      	adds	r3, #12
 80009ea:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80009ec:	68fb      	ldr	r3, [r7, #12]
 80009ee:	e853 3f00 	ldrex	r3, [r3]
 80009f2:	60bb      	str	r3, [r7, #8]
   return(result);
 80009f4:	68bb      	ldr	r3, [r7, #8]
 80009f6:	f023 0310 	bic.w	r3, r3, #16
 80009fa:	647b      	str	r3, [r7, #68]	@ 0x44
 80009fc:	687b      	ldr	r3, [r7, #4]
 80009fe:	681b      	ldr	r3, [r3, #0]
 8000a00:	330c      	adds	r3, #12
 8000a02:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8000a04:	61ba      	str	r2, [r7, #24]
 8000a06:	617b      	str	r3, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8000a08:	6979      	ldr	r1, [r7, #20]
 8000a0a:	69ba      	ldr	r2, [r7, #24]
 8000a0c:	e841 2300 	strex	r3, r2, [r1]
 8000a10:	613b      	str	r3, [r7, #16]
   return(result);
 8000a12:	693b      	ldr	r3, [r7, #16]
 8000a14:	2b00      	cmp	r3, #0
 8000a16:	d1e5      	bne.n	80009e4 <UART_EndRxTransfer+0x78>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8000a18:	687b      	ldr	r3, [r7, #4]
 8000a1a:	2220      	movs	r2, #32
 8000a1c:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8000a20:	687b      	ldr	r3, [r7, #4]
 8000a22:	2200      	movs	r2, #0
 8000a24:	631a      	str	r2, [r3, #48]	@ 0x30
}
 8000a26:	bf00      	nop
 8000a28:	3754      	adds	r7, #84	@ 0x54
 8000a2a:	46bd      	mov	sp, r7
 8000a2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a30:	4770      	bx	lr

08000a32 <UART_DMAAbortOnError>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8000a32:	b580      	push	{r7, lr}
 8000a34:	b084      	sub	sp, #16
 8000a36:	af00      	add	r7, sp, #0
 8000a38:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8000a3a:	687b      	ldr	r3, [r7, #4]
 8000a3c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8000a3e:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0x00U;
 8000a40:	68fb      	ldr	r3, [r7, #12]
 8000a42:	2200      	movs	r2, #0
 8000a44:	85da      	strh	r2, [r3, #46]	@ 0x2e
  huart->TxXferCount = 0x00U;
 8000a46:	68fb      	ldr	r3, [r7, #12]
 8000a48:	2200      	movs	r2, #0
 8000a4a:	84da      	strh	r2, [r3, #38]	@ 0x26
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8000a4c:	68f8      	ldr	r0, [r7, #12]
 8000a4e:	f7ff ff77 	bl	8000940 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8000a52:	bf00      	nop
 8000a54:	3710      	adds	r7, #16
 8000a56:	46bd      	mov	sp, r7
 8000a58:	bd80      	pop	{r7, pc}

08000a5a <UART_Transmit_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
 8000a5a:	b480      	push	{r7}
 8000a5c:	b085      	sub	sp, #20
 8000a5e:	af00      	add	r7, sp, #0
 8000a60:	6078      	str	r0, [r7, #4]
  const uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8000a62:	687b      	ldr	r3, [r7, #4]
 8000a64:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8000a68:	b2db      	uxtb	r3, r3
 8000a6a:	2b21      	cmp	r3, #33	@ 0x21
 8000a6c:	d13e      	bne.n	8000aec <UART_Transmit_IT+0x92>
  {
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8000a6e:	687b      	ldr	r3, [r7, #4]
 8000a70:	689b      	ldr	r3, [r3, #8]
 8000a72:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8000a76:	d114      	bne.n	8000aa2 <UART_Transmit_IT+0x48>
 8000a78:	687b      	ldr	r3, [r7, #4]
 8000a7a:	691b      	ldr	r3, [r3, #16]
 8000a7c:	2b00      	cmp	r3, #0
 8000a7e:	d110      	bne.n	8000aa2 <UART_Transmit_IT+0x48>
    {
      tmp = (const uint16_t *) huart->pTxBuffPtr;
 8000a80:	687b      	ldr	r3, [r7, #4]
 8000a82:	6a1b      	ldr	r3, [r3, #32]
 8000a84:	60fb      	str	r3, [r7, #12]
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 8000a86:	68fb      	ldr	r3, [r7, #12]
 8000a88:	881b      	ldrh	r3, [r3, #0]
 8000a8a:	461a      	mov	r2, r3
 8000a8c:	687b      	ldr	r3, [r7, #4]
 8000a8e:	681b      	ldr	r3, [r3, #0]
 8000a90:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8000a94:	605a      	str	r2, [r3, #4]
      huart->pTxBuffPtr += 2U;
 8000a96:	687b      	ldr	r3, [r7, #4]
 8000a98:	6a1b      	ldr	r3, [r3, #32]
 8000a9a:	1c9a      	adds	r2, r3, #2
 8000a9c:	687b      	ldr	r3, [r7, #4]
 8000a9e:	621a      	str	r2, [r3, #32]
 8000aa0:	e008      	b.n	8000ab4 <UART_Transmit_IT+0x5a>
    }
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 8000aa2:	687b      	ldr	r3, [r7, #4]
 8000aa4:	6a1b      	ldr	r3, [r3, #32]
 8000aa6:	1c59      	adds	r1, r3, #1
 8000aa8:	687a      	ldr	r2, [r7, #4]
 8000aaa:	6211      	str	r1, [r2, #32]
 8000aac:	781a      	ldrb	r2, [r3, #0]
 8000aae:	687b      	ldr	r3, [r7, #4]
 8000ab0:	681b      	ldr	r3, [r3, #0]
 8000ab2:	605a      	str	r2, [r3, #4]
    }

    if (--huart->TxXferCount == 0U)
 8000ab4:	687b      	ldr	r3, [r7, #4]
 8000ab6:	8cdb      	ldrh	r3, [r3, #38]	@ 0x26
 8000ab8:	b29b      	uxth	r3, r3
 8000aba:	3b01      	subs	r3, #1
 8000abc:	b29b      	uxth	r3, r3
 8000abe:	687a      	ldr	r2, [r7, #4]
 8000ac0:	4619      	mov	r1, r3
 8000ac2:	84d1      	strh	r1, [r2, #38]	@ 0x26
 8000ac4:	2b00      	cmp	r3, #0
 8000ac6:	d10f      	bne.n	8000ae8 <UART_Transmit_IT+0x8e>
    {
      /* Disable the UART Transmit Data Register Empty Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 8000ac8:	687b      	ldr	r3, [r7, #4]
 8000aca:	681b      	ldr	r3, [r3, #0]
 8000acc:	68da      	ldr	r2, [r3, #12]
 8000ace:	687b      	ldr	r3, [r7, #4]
 8000ad0:	681b      	ldr	r3, [r3, #0]
 8000ad2:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8000ad6:	60da      	str	r2, [r3, #12]

      /* Enable the UART Transmit Complete Interrupt */
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 8000ad8:	687b      	ldr	r3, [r7, #4]
 8000ada:	681b      	ldr	r3, [r3, #0]
 8000adc:	68da      	ldr	r2, [r3, #12]
 8000ade:	687b      	ldr	r3, [r7, #4]
 8000ae0:	681b      	ldr	r3, [r3, #0]
 8000ae2:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8000ae6:	60da      	str	r2, [r3, #12]
    }
    return HAL_OK;
 8000ae8:	2300      	movs	r3, #0
 8000aea:	e000      	b.n	8000aee <UART_Transmit_IT+0x94>
  }
  else
  {
    return HAL_BUSY;
 8000aec:	2302      	movs	r3, #2
  }
}
 8000aee:	4618      	mov	r0, r3
 8000af0:	3714      	adds	r7, #20
 8000af2:	46bd      	mov	sp, r7
 8000af4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000af8:	4770      	bx	lr

08000afa <UART_EndTransmit_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 8000afa:	b580      	push	{r7, lr}
 8000afc:	b082      	sub	sp, #8
 8000afe:	af00      	add	r7, sp, #0
 8000b00:	6078      	str	r0, [r7, #4]
  /* Disable the UART Transmit Complete Interrupt */
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8000b02:	687b      	ldr	r3, [r7, #4]
 8000b04:	681b      	ldr	r3, [r3, #0]
 8000b06:	68da      	ldr	r2, [r3, #12]
 8000b08:	687b      	ldr	r3, [r7, #4]
 8000b0a:	681b      	ldr	r3, [r3, #0]
 8000b0c:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8000b10:	60da      	str	r2, [r3, #12]

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8000b12:	687b      	ldr	r3, [r7, #4]
 8000b14:	2220      	movs	r2, #32
 8000b16:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 8000b1a:	6878      	ldr	r0, [r7, #4]
 8000b1c:	f7ff fefc 	bl	8000918 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

  return HAL_OK;
 8000b20:	2300      	movs	r3, #0
}
 8000b22:	4618      	mov	r0, r3
 8000b24:	3708      	adds	r7, #8
 8000b26:	46bd      	mov	sp, r7
 8000b28:	bd80      	pop	{r7, pc}

08000b2a <UART_Receive_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
 8000b2a:	b580      	push	{r7, lr}
 8000b2c:	b08c      	sub	sp, #48	@ 0x30
 8000b2e:	af00      	add	r7, sp, #0
 8000b30:	6078      	str	r0, [r7, #4]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8000b32:	687b      	ldr	r3, [r7, #4]
 8000b34:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8000b38:	b2db      	uxtb	r3, r3
 8000b3a:	2b22      	cmp	r3, #34	@ 0x22
 8000b3c:	f040 80ae 	bne.w	8000c9c <UART_Receive_IT+0x172>
  {
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8000b40:	687b      	ldr	r3, [r7, #4]
 8000b42:	689b      	ldr	r3, [r3, #8]
 8000b44:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8000b48:	d117      	bne.n	8000b7a <UART_Receive_IT+0x50>
 8000b4a:	687b      	ldr	r3, [r7, #4]
 8000b4c:	691b      	ldr	r3, [r3, #16]
 8000b4e:	2b00      	cmp	r3, #0
 8000b50:	d113      	bne.n	8000b7a <UART_Receive_IT+0x50>
    {
      pdata8bits  = NULL;
 8000b52:	2300      	movs	r3, #0
 8000b54:	62fb      	str	r3, [r7, #44]	@ 0x2c
      pdata16bits = (uint16_t *) huart->pRxBuffPtr;
 8000b56:	687b      	ldr	r3, [r7, #4]
 8000b58:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000b5a:	62bb      	str	r3, [r7, #40]	@ 0x28
      *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8000b5c:	687b      	ldr	r3, [r7, #4]
 8000b5e:	681b      	ldr	r3, [r3, #0]
 8000b60:	685b      	ldr	r3, [r3, #4]
 8000b62:	b29b      	uxth	r3, r3
 8000b64:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8000b68:	b29a      	uxth	r2, r3
 8000b6a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8000b6c:	801a      	strh	r2, [r3, #0]
      huart->pRxBuffPtr += 2U;
 8000b6e:	687b      	ldr	r3, [r7, #4]
 8000b70:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000b72:	1c9a      	adds	r2, r3, #2
 8000b74:	687b      	ldr	r3, [r7, #4]
 8000b76:	629a      	str	r2, [r3, #40]	@ 0x28
 8000b78:	e026      	b.n	8000bc8 <UART_Receive_IT+0x9e>
    }
    else
    {
      pdata8bits = (uint8_t *) huart->pRxBuffPtr;
 8000b7a:	687b      	ldr	r3, [r7, #4]
 8000b7c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000b7e:	62fb      	str	r3, [r7, #44]	@ 0x2c
      pdata16bits  = NULL;
 8000b80:	2300      	movs	r3, #0
 8000b82:	62bb      	str	r3, [r7, #40]	@ 0x28

      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 8000b84:	687b      	ldr	r3, [r7, #4]
 8000b86:	689b      	ldr	r3, [r3, #8]
 8000b88:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8000b8c:	d007      	beq.n	8000b9e <UART_Receive_IT+0x74>
 8000b8e:	687b      	ldr	r3, [r7, #4]
 8000b90:	689b      	ldr	r3, [r3, #8]
 8000b92:	2b00      	cmp	r3, #0
 8000b94:	d10a      	bne.n	8000bac <UART_Receive_IT+0x82>
 8000b96:	687b      	ldr	r3, [r7, #4]
 8000b98:	691b      	ldr	r3, [r3, #16]
 8000b9a:	2b00      	cmp	r3, #0
 8000b9c:	d106      	bne.n	8000bac <UART_Receive_IT+0x82>
      {
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8000b9e:	687b      	ldr	r3, [r7, #4]
 8000ba0:	681b      	ldr	r3, [r3, #0]
 8000ba2:	685b      	ldr	r3, [r3, #4]
 8000ba4:	b2da      	uxtb	r2, r3
 8000ba6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8000ba8:	701a      	strb	r2, [r3, #0]
 8000baa:	e008      	b.n	8000bbe <UART_Receive_IT+0x94>
      }
      else
      {
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8000bac:	687b      	ldr	r3, [r7, #4]
 8000bae:	681b      	ldr	r3, [r3, #0]
 8000bb0:	685b      	ldr	r3, [r3, #4]
 8000bb2:	b2db      	uxtb	r3, r3
 8000bb4:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8000bb8:	b2da      	uxtb	r2, r3
 8000bba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8000bbc:	701a      	strb	r2, [r3, #0]
      }
      huart->pRxBuffPtr += 1U;
 8000bbe:	687b      	ldr	r3, [r7, #4]
 8000bc0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000bc2:	1c5a      	adds	r2, r3, #1
 8000bc4:	687b      	ldr	r3, [r7, #4]
 8000bc6:	629a      	str	r2, [r3, #40]	@ 0x28
    }

    if (--huart->RxXferCount == 0U)
 8000bc8:	687b      	ldr	r3, [r7, #4]
 8000bca:	8ddb      	ldrh	r3, [r3, #46]	@ 0x2e
 8000bcc:	b29b      	uxth	r3, r3
 8000bce:	3b01      	subs	r3, #1
 8000bd0:	b29b      	uxth	r3, r3
 8000bd2:	687a      	ldr	r2, [r7, #4]
 8000bd4:	4619      	mov	r1, r3
 8000bd6:	85d1      	strh	r1, [r2, #46]	@ 0x2e
 8000bd8:	2b00      	cmp	r3, #0
 8000bda:	d15d      	bne.n	8000c98 <UART_Receive_IT+0x16e>
    {
      /* Disable the UART Data Register not empty Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 8000bdc:	687b      	ldr	r3, [r7, #4]
 8000bde:	681b      	ldr	r3, [r3, #0]
 8000be0:	68da      	ldr	r2, [r3, #12]
 8000be2:	687b      	ldr	r3, [r7, #4]
 8000be4:	681b      	ldr	r3, [r3, #0]
 8000be6:	f022 0220 	bic.w	r2, r2, #32
 8000bea:	60da      	str	r2, [r3, #12]

      /* Disable the UART Parity Error Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 8000bec:	687b      	ldr	r3, [r7, #4]
 8000bee:	681b      	ldr	r3, [r3, #0]
 8000bf0:	68da      	ldr	r2, [r3, #12]
 8000bf2:	687b      	ldr	r3, [r7, #4]
 8000bf4:	681b      	ldr	r3, [r3, #0]
 8000bf6:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 8000bfa:	60da      	str	r2, [r3, #12]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 8000bfc:	687b      	ldr	r3, [r7, #4]
 8000bfe:	681b      	ldr	r3, [r3, #0]
 8000c00:	695a      	ldr	r2, [r3, #20]
 8000c02:	687b      	ldr	r3, [r7, #4]
 8000c04:	681b      	ldr	r3, [r3, #0]
 8000c06:	f022 0201 	bic.w	r2, r2, #1
 8000c0a:	615a      	str	r2, [r3, #20]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8000c0c:	687b      	ldr	r3, [r7, #4]
 8000c0e:	2220      	movs	r2, #32
 8000c10:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

      /* Initialize type of RxEvent to Transfer Complete */
      huart->RxEventType = HAL_UART_RXEVENT_TC;
 8000c14:	687b      	ldr	r3, [r7, #4]
 8000c16:	2200      	movs	r2, #0
 8000c18:	635a      	str	r2, [r3, #52]	@ 0x34

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8000c1a:	687b      	ldr	r3, [r7, #4]
 8000c1c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8000c1e:	2b01      	cmp	r3, #1
 8000c20:	d135      	bne.n	8000c8e <UART_Receive_IT+0x164>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8000c22:	687b      	ldr	r3, [r7, #4]
 8000c24:	2200      	movs	r2, #0
 8000c26:	631a      	str	r2, [r3, #48]	@ 0x30

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8000c28:	687b      	ldr	r3, [r7, #4]
 8000c2a:	681b      	ldr	r3, [r3, #0]
 8000c2c:	330c      	adds	r3, #12
 8000c2e:	617b      	str	r3, [r7, #20]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8000c30:	697b      	ldr	r3, [r7, #20]
 8000c32:	e853 3f00 	ldrex	r3, [r3]
 8000c36:	613b      	str	r3, [r7, #16]
   return(result);
 8000c38:	693b      	ldr	r3, [r7, #16]
 8000c3a:	f023 0310 	bic.w	r3, r3, #16
 8000c3e:	627b      	str	r3, [r7, #36]	@ 0x24
 8000c40:	687b      	ldr	r3, [r7, #4]
 8000c42:	681b      	ldr	r3, [r3, #0]
 8000c44:	330c      	adds	r3, #12
 8000c46:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8000c48:	623a      	str	r2, [r7, #32]
 8000c4a:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8000c4c:	69f9      	ldr	r1, [r7, #28]
 8000c4e:	6a3a      	ldr	r2, [r7, #32]
 8000c50:	e841 2300 	strex	r3, r2, [r1]
 8000c54:	61bb      	str	r3, [r7, #24]
   return(result);
 8000c56:	69bb      	ldr	r3, [r7, #24]
 8000c58:	2b00      	cmp	r3, #0
 8000c5a:	d1e5      	bne.n	8000c28 <UART_Receive_IT+0xfe>

        /* Check if IDLE flag is set */
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
 8000c5c:	687b      	ldr	r3, [r7, #4]
 8000c5e:	681b      	ldr	r3, [r3, #0]
 8000c60:	681b      	ldr	r3, [r3, #0]
 8000c62:	f003 0310 	and.w	r3, r3, #16
 8000c66:	2b10      	cmp	r3, #16
 8000c68:	d10a      	bne.n	8000c80 <UART_Receive_IT+0x156>
        {
          /* Clear IDLE flag in ISR */
          __HAL_UART_CLEAR_IDLEFLAG(huart);
 8000c6a:	2300      	movs	r3, #0
 8000c6c:	60fb      	str	r3, [r7, #12]
 8000c6e:	687b      	ldr	r3, [r7, #4]
 8000c70:	681b      	ldr	r3, [r3, #0]
 8000c72:	681b      	ldr	r3, [r3, #0]
 8000c74:	60fb      	str	r3, [r7, #12]
 8000c76:	687b      	ldr	r3, [r7, #4]
 8000c78:	681b      	ldr	r3, [r3, #0]
 8000c7a:	685b      	ldr	r3, [r3, #4]
 8000c7c:	60fb      	str	r3, [r7, #12]
 8000c7e:	68fb      	ldr	r3, [r7, #12]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8000c80:	687b      	ldr	r3, [r7, #4]
 8000c82:	8d9b      	ldrh	r3, [r3, #44]	@ 0x2c
 8000c84:	4619      	mov	r1, r3
 8000c86:	6878      	ldr	r0, [r7, #4]
 8000c88:	f7ff fe64 	bl	8000954 <HAL_UARTEx_RxEventCallback>
 8000c8c:	e002      	b.n	8000c94 <UART_Receive_IT+0x16a>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxCpltCallback(huart);
#else
        /*Call legacy weak Rx complete callback*/
        HAL_UART_RxCpltCallback(huart);
 8000c8e:	6878      	ldr	r0, [r7, #4]
 8000c90:	f7ff fe4c 	bl	800092c <HAL_UART_RxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      }

      return HAL_OK;
 8000c94:	2300      	movs	r3, #0
 8000c96:	e002      	b.n	8000c9e <UART_Receive_IT+0x174>
    }
    return HAL_OK;
 8000c98:	2300      	movs	r3, #0
 8000c9a:	e000      	b.n	8000c9e <UART_Receive_IT+0x174>
  }
  else
  {
    return HAL_BUSY;
 8000c9c:	2302      	movs	r3, #2
  }
}
 8000c9e:	4618      	mov	r0, r3
 8000ca0:	3730      	adds	r7, #48	@ 0x30
 8000ca2:	46bd      	mov	sp, r7
 8000ca4:	bd80      	pop	{r7, pc}
	...

08000ca8 <__libc_init_array>:
 8000ca8:	b570      	push	{r4, r5, r6, lr}
 8000caa:	4d0d      	ldr	r5, [pc, #52]	@ (8000ce0 <__libc_init_array+0x38>)
 8000cac:	4c0d      	ldr	r4, [pc, #52]	@ (8000ce4 <__libc_init_array+0x3c>)
 8000cae:	1b64      	subs	r4, r4, r5
 8000cb0:	10a4      	asrs	r4, r4, #2
 8000cb2:	2600      	movs	r6, #0
 8000cb4:	42a6      	cmp	r6, r4
 8000cb6:	d109      	bne.n	8000ccc <__libc_init_array+0x24>
 8000cb8:	4d0b      	ldr	r5, [pc, #44]	@ (8000ce8 <__libc_init_array+0x40>)
 8000cba:	4c0c      	ldr	r4, [pc, #48]	@ (8000cec <__libc_init_array+0x44>)
 8000cbc:	f000 f818 	bl	8000cf0 <_init>
 8000cc0:	1b64      	subs	r4, r4, r5
 8000cc2:	10a4      	asrs	r4, r4, #2
 8000cc4:	2600      	movs	r6, #0
 8000cc6:	42a6      	cmp	r6, r4
 8000cc8:	d105      	bne.n	8000cd6 <__libc_init_array+0x2e>
 8000cca:	bd70      	pop	{r4, r5, r6, pc}
 8000ccc:	f855 3b04 	ldr.w	r3, [r5], #4
 8000cd0:	4798      	blx	r3
 8000cd2:	3601      	adds	r6, #1
 8000cd4:	e7ee      	b.n	8000cb4 <__libc_init_array+0xc>
 8000cd6:	f855 3b04 	ldr.w	r3, [r5], #4
 8000cda:	4798      	blx	r3
 8000cdc:	3601      	adds	r6, #1
 8000cde:	e7f2      	b.n	8000cc6 <__libc_init_array+0x1e>
 8000ce0:	08000d08 	.word	0x08000d08
 8000ce4:	08000d08 	.word	0x08000d08
 8000ce8:	08000d08 	.word	0x08000d08
 8000cec:	08000d0c 	.word	0x08000d0c

08000cf0 <_init>:
 8000cf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000cf2:	bf00      	nop
 8000cf4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000cf6:	bc08      	pop	{r3}
 8000cf8:	469e      	mov	lr, r3
 8000cfa:	4770      	bx	lr

08000cfc <_fini>:
 8000cfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000cfe:	bf00      	nop
 8000d00:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000d02:	bc08      	pop	{r3}
 8000d04:	469e      	mov	lr, r3
 8000d06:	4770      	bx	lr
